<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2020%2F06%2F22%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[PAT中常用的进制转化，包括string、vector和int间的按进制转换。string类型可以直接使用iostream读入:cin &gt;&gt; str具体写法如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;int toNumber_str(string x, int radix) &#123; int a = 0; for (int i = 0; i &lt; x.size(); i++) &#123; a = a * radix + (x[i] - '0'); &#125; return a;&#125;int toNumber_vec(vector&lt;int&gt; x, int radix) &#123; int a = 0; for (int i = 0; i &lt; x.size(); i++) &#123; a = a * radix + x[i]; &#125; return a;&#125;string toString(int num,int radix)&#123; string s = ""; while(num!=0)&#123; char a[10]; sprintf(a,"%d",num % radix); string str = a; s += a; num /= radix; &#125; return s;&#125;vector&lt;int&gt; toVector(int num,int radix)&#123; vector&lt;int&gt; vec; while(num!=0)&#123; vec.push_back(num % radix); num /= radix; &#125; return vec;&#125;int main() &#123; /* * 字符串,int数组按进制转int */ string s = "12345"; vector&lt;int&gt; vec; for(int i = 1;i &lt;= 5;i++)&#123; vec.push_back(i); &#125; cout &lt;&lt; toNumber_str(s,10)&lt;&lt;endl;//12345 cout &lt;&lt; toNumber_vec(vec,10)&lt;&lt;endl;//12345 /* * int按进制转字符串,int数组（逆向） */ int a = 12345; vector&lt;int&gt; v = toVector(a,10);//"54321" string str = toString(a,10);//"54321" /* * int转字符串（正向，仅支持10进制） */ char b[10]; int size = sprintf(b,"%d",a); for(int i = 0;i &lt; size;i++) cout &lt;&lt; b[i];//"12345"&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1006-1014]]></title>
    <url>%2F2020%2F06%2F21%2FPAT1006-1014%2F</url>
    <content type="text"><![CDATA[1006 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; string id; string in; string out;&#125; Node;bool cmp1(Node a, Node b) &#123; string str1 = a.in; string str2 = b.in; string HH1 = str1.substr(0, 2); string MM1 = str1.substr(3, 2); string SS1 = str1.substr(6, 2); string HH2 = str2.substr(0, 2); string MM2 = str2.substr(3, 2); string SS2 = str2.substr(6, 2); if (HH1 == HH2) &#123; if (MM1 == MM2) &#123; return SS1 &lt; SS2; &#125; else return MM1 &lt; MM2; &#125; else return HH1 &lt; HH2;&#125;bool cmp2(Node a, Node b) &#123; string str1 = a.out; string str2 = b.out; string HH1 = str1.substr(0, 2); string MM1 = str1.substr(3, 2); string SS1 = str1.substr(6, 2); string HH2 = str2.substr(0, 2); string MM2 = str2.substr(3, 2); string SS2 = str2.substr(6, 2); if (HH1 == HH2) &#123; if (MM1 == MM2) &#123; return SS1 &gt; SS2; &#125; else return MM1 &gt; MM2; &#125; else return HH1 &gt; HH2;&#125;int main() &#123; int n; cin &gt;&gt; n; Node node[n]; for (int i = 0; i &lt; n; i++) &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; node[i].id = a; node[i].in = b; node[i].out = c; &#125; sort(node, node + n, cmp1); cout &lt;&lt; node[0].id &lt;&lt; " "; sort(node, node + n, cmp2); cout &lt;&lt; node[0].id ;&#125; 100712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; /* * 活用递推，先求S[i] = S[i-1] + a[i] * 从左至右找到最大的一个S，下标为index2 * 从0至index2找到最小的一个S，下标为index1 * 答案为a[index1+1]~a[index2] */ int K; vector&lt;int&gt; a; vector&lt;int&gt; s; cin &gt;&gt; K; for (int i = 0; i &lt; K; i++) &#123; int temp; cin &gt;&gt; temp; a.push_back(temp); &#125; int MIN = 100000000; int MAX = -100000000; int index1 = -1, index2 = -1; s.push_back(a[0]); for (int i = 1; i &lt; K; i++) &#123; s.push_back(s[i - 1] + a[i]); &#125; for (int i = 0; i &lt; K; i++) &#123; if (s[i] &gt; MAX) &#123; MAX = s[i]; index2 = i; &#125; &#125; if(MAX &lt; 0)&#123;//如果最大的s还是负的或0，此时可能出现尽管S都负但a[n]中存在正数的情况，因此需要找到第二大的S 例如&#123;-1 -1 1 -3&#125; MAX = -100000000; for (int i = index2 + 1; i &lt; K; i++) &#123; if (s[i] &gt; MAX) &#123; MAX = s[i]; index2 = i; &#125; &#125; &#125; for (int i = 0; i &lt; index2; i++) &#123; if (s[i] &lt; MIN) &#123; MIN = s[i]; index1 = i; &#125; &#125; index1 += 1; bool isAllNeg = true; for(int i =0;i &lt; K;i++)&#123; if(a[i]&gt;=0)&#123; isAllNeg = false; break; &#125; &#125; if (isAllNeg) &#123; cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; a[0] &lt;&lt; " " &lt;&lt; a[K-1]; &#125; else &#123; int sum = 0; for (int i = index1; i &lt;= index2; i++) &#123; sum = sum + a[i]; &#125; cout &lt;&lt; sum &lt;&lt; " " &lt;&lt; a[index1] &lt;&lt; " " &lt;&lt; a[index2]; &#125;&#125; 1008123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, total = 0, now = 0, to; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;to; if (to &gt; now)total += ((to - now) * 6); else total += ((now - to) * 4); total += 5; now = to; &#125; cout &lt;&lt; total; return 0;&#125; 1009123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct Poly&#123; vector&lt;int&gt; exp; double coef[2005]; Poly()&#123; fill(coef,coef+2005,0.0); &#125;&#125;Poly;int main()&#123; int k; Poly poly1,poly2; cin &gt;&gt; k; for(int i = 0;i &lt; k;i++)&#123; int p1; double p2; cin &gt;&gt; p1 &gt;&gt; p2; poly1.exp.push_back(p1); poly1.coef[p1] = p2; &#125; cin &gt;&gt; k; for(int i = 0;i &lt; k;i++)&#123; int p1; double p2; cin &gt;&gt; p1 &gt;&gt; p2; poly2.exp.push_back(p1); poly2.coef[p1] = p2; &#125; Poly poly3; int hasExp[2005]; fill(hasExp,hasExp+2005,0); for(int i = 0;i &lt; poly1.exp.size();i++)&#123; for(int j = 0;j &lt; poly2.exp.size();j++)&#123; int exp = poly1.exp[i]+poly2.exp[j]; double coef = poly1.coef[poly1.exp[i]]*poly2.coef[poly2.exp[j]]; if(hasExp[exp]==0)&#123; poly3.exp.push_back(exp); hasExp[exp] = 1; &#125; poly3.coef[exp]+=coef; &#125; &#125; int cnt = 0; for(int i = 2004;i &gt;= 0;i--)&#123; if(hasExp[i] == 1 &amp;&amp; poly3.coef[i]!=0)&#123; cnt++; &#125; &#125; if(cnt==0) cout &lt;&lt;"0";//如果输出一项没有 注意0后面不要有空格 else cout &lt;&lt; cnt &lt;&lt; " "; int num = 0; for(int i = 2004;i &gt;= 0;i--)&#123; if(hasExp[i] == 1 &amp;&amp; poly3.coef[i]!=0)&#123; num++; cout &lt;&lt; i &lt;&lt; " "; printf("%.1lf",poly3.coef[i]); if(num &lt; cnt) cout &lt;&lt; " ";//去尾空格 &#125; &#125;&#125; 1010123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;char tmp1[15],str1[15];char tmp2[15],str2[15];long long num1=0,num2=0; int flag;typedef long long LL;LL radix;LL inf=(1LL&lt;&lt;63)-1; long long convert(char str[],LL radix,LL t)&#123; long long num=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; num=num*radix+str[i]-'0'; &#125; else if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z')&#123; num=num*radix+(str[i]-'a'+10); &#125; &#125; if(num&lt;0) return -1; return num;&#125; int findLargest(char str[])&#123; int MAX=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9') MAX=max(MAX,str[i]-'0'); else if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') MAX=max(MAX,str[i]-'a'+10); &#125; return MAX+1;&#125; int main()&#123; scanf("%s %s %d %d",tmp1,tmp2,&amp;flag,&amp;radix); if(flag==1)&#123; strcpy(str1,tmp1); strcpy(str2,tmp2); &#125; else if(flag==2)&#123; strcpy(str1,tmp2); strcpy(str2,tmp1); &#125; num1=convert(str1,radix,inf); long long l=0,r=400,mid; l=findLargest(str2); r=max(l,num1)+1; bool f=false; while(l&lt;r)&#123; mid=(l+r)/2; long long tmp=convert(str2,mid,inf); if(tmp==-1) r=mid; else if(tmp==num1)&#123; printf("%lld\n",mid); f=true; break; &#125; else if(tmp&lt;num1) l=mid+1; else r=mid; &#125; if(f==false) printf("Impossible\n"); return 0;&#125; 1011123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;double a[3],b[3],c[3];typedef struct Node&#123; int index; double max;&#125;Node;Node findMax(double x[])&#123; Node node; double max = -1.0; int index = -1; for(int i =0;i &lt; 3;i++)&#123; if(x[i]&gt;max)&#123; max = x[i]; index = i; &#125; &#125; node.index = index; node.max = max; return node;&#125;int main()&#123; cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2]; cin &gt;&gt; b[0] &gt;&gt; b[1] &gt;&gt; b[2]; cin &gt;&gt; c[0] &gt;&gt; c[1] &gt;&gt; c[2]; Node node1 = findMax(a); Node node2 = findMax(b); Node node3 = findMax(c); char mp[3]=&#123;'W','T','L'&#125;; cout &lt;&lt; mp[node1.index]&lt;&lt;" "&lt;&lt;mp[node2.index]&lt;&lt;" "&lt;&lt; mp[node3.index]&lt;&lt;" "; printf("%.2lf",(0.65*node1.max*node2.max*node3.max-1)*2);&#125; 1012123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;typedef struct Node &#123; int id; int C, M, E, A, rC, rM, rE, rA;&#125; Node;bool cmp1(Node a, Node b) &#123; return a.C &gt; b.C;&#125;bool cmp2(Node a, Node b) &#123; return a.M &gt; b.M;&#125;bool cmp3(Node a, Node b) &#123; return a.E &gt; b.E;&#125;bool cmp4(Node a, Node b) &#123; return a.A &gt; b.A;&#125;int main() &#123; int N, M; cin &gt;&gt; N &gt;&gt; M; Node node[N]; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; node[i].id &gt;&gt; node[i].C &gt;&gt; node[i].M &gt;&gt; node[i].E; node[i].A = (node[i].C + node[i].M + node[i].E) / 3; &#125; sort(node, node + N, cmp1); node[0].rC = 1; int temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].C == node[i-1].C)&#123; node[i].rC = node[i-1].rC; temp++; &#125; else node[i].rC = ++temp; &#125; sort(node, node + N, cmp2); node[0].rM = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].M == node[i-1].M)&#123; node[i].rM = node[i-1].rM; temp++; &#125; else node[i].rM = ++temp; &#125; sort(node, node + N, cmp3); node[0].rE = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].E == node[i-1].E)&#123; node[i].rE = node[i-1].rE; temp++; &#125; else node[i].rE = ++temp; &#125; sort(node, node + N, cmp4); node[0].rA = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].A == node[i-1].A)&#123; node[i].rA = node[i-1].rA; temp++; &#125; else node[i].rA = ++temp; &#125; map&lt;int, Node&gt; mp; for (int i = 0; i &lt; N; i++) &#123; mp[node[i].id] = node[i]; &#125; for (int i = 0; i &lt; M; i++) &#123; int input; cin &gt;&gt; input; if (mp.find(input) == mp.end()) cout &lt;&lt; "N/A"&lt;&lt;endl; else &#123; Node t = mp[input]; int rank = 100000; int index = -1; int acme[4]; char hashMap[4]; acme[0] = t.rA; hashMap[0] = 'A'; acme[1] = t.rC; hashMap[1] = 'C'; acme[2] = t.rM; hashMap[2] = 'M'; acme[3] = t.rE; hashMap[3] = 'E'; for (int j = 0; j &lt; 4; j++) &#123; if (acme[j] &lt; rank) &#123; rank = acme[j]; index = j; &#125; &#125; cout &lt;&lt; rank &lt;&lt; " " &lt;&lt; hashMap[index] &lt;&lt; endl; &#125; &#125;&#125; 10131234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; Adj[1010];bool isVisit[1010] = &#123;false&#125;;int num = 0;void DFS(int s,vector&lt;int&gt; a[]) &#123; isVisit[s] = true; for (int i = 0; i &lt; a[s].size(); i++) &#123; if (!isVisit[a[s][i]]) DFS(a[s][i],a); &#125;&#125;int main() &#123; int N, M, K; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; M; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Adj[a].push_back(b); Adj[b].push_back(a); &#125; vector&lt;int&gt; Adj_copy[1010]; for (int i = 0; i &lt; K; i++) &#123; for (int m = 0; m &lt; N + 1; m++) &#123; Adj_copy[m] = Adj[m]; &#125; int t; cin &gt;&gt; t; Adj_copy[t].clear(); for (int j = 1; j &lt; N + 1; j++) &#123; for (auto it = Adj_copy[j].begin(); it &lt; Adj_copy[j].end(); it++) &#123; if (*it == t) Adj_copy[j].erase(it); &#125; &#125; num = 0; fill(isVisit, isVisit + 1010, false); for (int k = 1; k &lt; N + 1; k++) &#123; if (!isVisit[k]) &#123; DFS(k,Adj_copy); num++; &#125; &#125; cout &lt;&lt; num - 2 &lt;&lt; endl; &#125;&#125; 1014123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct Node&#123; int time1; int time2;&#125;node[1010];typedef struct Time&#123; int HH; int MM;&#125;Time;vector&lt;queue&lt;int&gt; &gt; queues;vector&lt;vector&lt;int&gt; &gt; vec_queues;int time_consume[1010];Time SS2HHMM(int s)&#123;//秒数转为HH:MM int h = 8 + s / 60; int m = s - (s / 60) * 60; Time time; time.HH = h; time.MM = m; return time;&#125;int main()&#123; int N,M,K,Q; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; Q; for(int i = 0;i &lt; N;i++)&#123; queue&lt;int&gt; q; vector&lt;int&gt; v; queues.push_back(q); vec_queues.push_back(v); &#125; for(int i = 1;i &lt; K+1;i++)&#123; cin &gt;&gt; time_consume[i]; &#125; int index = 1; for(int s = 0; s &lt; M;s++)&#123; for(int i = 0;i &lt; queues.size();i++)&#123; queues[i].push(index); vec_queues[i].push_back(index); int vec_size = vec_queues[i].size(); node[index].time1 = 0; if(index == queues[i].front())&#123; node[index].time2 = time_consume[index]; &#125;else&#123; node[index].time2 = node[vec_queues[i][vec_size - 2]].time2 + time_consume[index]; &#125; index++; &#125; &#125; bool isFinished = true;// for(int i = 0;i &lt; queues.size();i++)&#123;// if(!queues[i].empty()) isFinished = false;// &#125; while(index &lt;= K)&#123; int min = 100000; int t = -1; for(int i = 0;i &lt; queues.size();i++)&#123; if(node[queues[i].front()].time2 &lt; min)&#123; min = node[queues[i].front()].time2; t = i; &#125; &#125; int front = queues[t].front(); queues[t].pop(); queues[t].push(index); node[index].time1 = node[front].time2; vec_queues[t].push_back(index); int vec_size = vec_queues[t].size(); node[index].time2 = node[vec_queues[t][vec_size - 2]].time2 + time_consume[index]; index++; &#125; for(int i = 0;i &lt; Q;i++)&#123; int q; cin &gt;&gt; q; int start_time = node[q].time1; int finish_time = node[q].time2; if((finish_time - time_consume[q]) &gt;= 540) cout &lt;&lt; "Sorry"&lt;&lt;endl; else &#123; printf("%02d:%02d\n",SS2HHMM(finish_time).HH,SS2HHMM(finish_time).MM); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Djikstra题型总结]]></title>
    <url>%2F2020%2F06%2F14%2FDjikstra%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述使用Dijkstra的最短路的问题通常不仅要求给出最短路径，还附带以下几种题型或其组合： 额外增加一个边权，用于最短路径相同情况下的比较； 额外增加一个点权，用于最短路径相同情况下的比较； 问有多少种最短路； 输出最短路经过节点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXV = 510; //最大顶点数，通常取题目所给条件的上限+（5～10）即可const int INF = 100000000;//定义一个很大的数vector&lt;int&gt; Adj[MAXV];//图的邻接表（可以选择用vector&lt;Node&gt; Adj[] 结构体中放入边权和点权）int d[MAXV];//第一线权（从起点s到顶点u的最短路程为d[u]）int w[MAXV];//点权（从起点s到顶点u能收集到的最多的点权为w[u]）int c[MAXV];//第二线权（从起点s到顶点u花费的最少线权为c[u]）int num[MAXV];//记录相同距离路径个数int pre[MAXV];//从起点到v的最短路径的v的前一个节点为pre[v]int weight[MAXV];//存储输入的点权int dist[MAXV][MAXV];//存储输入的第一线权int cost[MAXV][MAXV];//存储输入的第二线权bool isVisit[MAXV];//用来记录是否访问过int M,N;void Dijkstra(int s);void print_route(int s, int v);int main()&#123; /* * 输入的格式 * N（节点个数） M（边个数） * w1 w2 ... wN （点权） * v1 v2 distance cost (两顶点编号，以及两者间的两种边权) */ cin &gt;&gt; M &gt;&gt; N; for(int i = 0;i &lt; N;i++)&#123; int temp; cin &gt;&gt; temp; weight[i] = temp; &#125; for(int i = 0; i &lt; M;i++)&#123; int v1,v2,distance,cost_; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; distance &gt;&gt; cost_; dist[v1][v2] = distance; cost[v1][v2] = cost_; &#125; /* * 初始化全局变量 */ fill(d,d+MAXV,INF);//初始d都为0 fill(w,w+MAXV,0); fill(c,c+MAXV,0); fill(num,num+MAXV,0); num[0] = 1; Dijkstra(0);&#125;void Dijkstra(int s)&#123;//s为起点 d[s] = 0;//起点到自己距离为0 int u = -1;//用来记录当前的顶点 for(int i = 0; i &lt; N; i++)&#123;//计算到每个点的最短路径 int MIN = INF; for(int j = 0;j &lt; N;j++)&#123; if(isVisit[j]== false &amp;&amp; d[j] &lt; MIN)&#123; u = j; MIN = d[j]; &#125; &#125; isVisit[u] = true; for(int j=0; j &lt; Adj[u].size();j++)&#123; int v = Adj[u][j]; if(isVisit[v] == false &amp;&amp; d[u] + dist[u][v] &lt; d[v])&#123;//优先级：第一线 &gt; 第二线 &gt; 点 d[v] = d[u] + dist[u][v];//第一线权 c[v] = c[u] + cost[u][v];//第二线权 w[v] = w[u] + weight[v];//点权 num[v] = num[u]; pre[v] = u; &#125;else if(isVisit[v] == false &amp;&amp; d[u] + dist[u][v] == d[v])&#123; num[v] = num[v] + num[u];//加法原理 if(c[v] &gt; c[u] + cost[u][v])&#123; c[v] = c[u] + cost[u][v];//选择更小的花费 pre[v] = u; &#125;else if(c[v] == c[u] + cost[u][v])&#123; if(w[v] &lt; w[u] + weight[v])&#123; w[v] = w[u] + weight[v]; pre[v] = u; &#125; &#125; &#125; &#125; print_route(s, i); cout &lt;&lt; "\n"; &#125;&#125;void print_route(int s, int v)&#123;//类似于并查集或DFS if(v==s)&#123; cout &lt;&lt; s; return; &#125; print_route(s,pre[v]); cout &lt;&lt; v;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1005]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1005%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string input; cin &gt;&gt; input;//cin直接传给string类型，注意这是STL里的string，不是cstring int sum = 0; for(int i = 0;i &lt; input.size(); i++)&#123; sum += input[i] - '0'; &#125; string hash[10]; hash[0] = "zero"; hash[1] = "one"; hash[2] = "two"; hash[3] = "three"; hash[4] = "four"; hash[5] = "five"; hash[6] = "six"; hash[7] = "seven"; hash[8] = "eight"; hash[9] = "nine"; char output[1000]; int num = sprintf(output,"%d",sum); /* sprintf函数，可以手写，类似于进制转换，将int型转换为数字字符串，返回值为转换成的字符串的大小（不包括结尾\0） **/ for(int i = 0; i &lt; num; i++)&#123; if(i == 0) cout &lt;&lt; hash[output[i] - '0']; else cout&lt;&lt;" "&lt;&lt; hash[output[i] - '0']; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1004]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1004%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 105;vector&lt;int&gt; Node[N];int level[N] = &#123;0&#125;;int leaf[N] = &#123;0&#125;;int max_level = 0;void BFS()&#123; queue&lt;int&gt; Q; Q.push(1); while(!Q.empty())&#123; int front = Q.front(); Q.pop(); max_level = max(max_level,level[front]); if(Node[front].size() == 0)&#123; leaf[level[front]]++; &#125; for(int i = 0; i &lt; Node[front].size(); i++)&#123; level[Node[front][i]] = level[front] + 1; Q.push(Node[front][i]); &#125; &#125;&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; int parent, k, child; cin &gt;&gt; parent &gt;&gt; k; for(int j =0; j &lt; k;j++)&#123; cin &gt;&gt; child; Node[parent].push_back(child); &#125; &#125; BFS(); for(int i = 0; i &lt;= max_level; i++)&#123; if(i == 0) cout &lt;&lt; leaf[i]; else cout &lt;&lt; " " &lt;&lt; leaf[i]; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1003]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1003%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct Node&#123; int v; int dist;&#125;;const int INF = 10000000;int N,M,C1,C2;vector&lt;Node&gt; Adj[510];int dot_weight[510];int d[510];int W[510];int cnt[510];bool isVisit[510] = &#123;false&#125;;void Dijkstra(int s);int main()&#123; fill(d,d+510,INF);//两种不同方法效果一样 //memset(d,INF,sizeof(d)); fill(W,W+510,0); fill(cnt,cnt+510,1); fill(dot_weight,dot_weight+510,0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; for(int i =0;i &lt; N ;i++)&#123; cin &gt;&gt; dot_weight[i]; &#125; for(int i = 0;i &lt; M;i++)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Node node1, node2; node1.v = a; node2.v = b; node1.dist = node2.dist = c; Adj[a].push_back(node2); Adj[b].push_back(node1); &#125; Dijkstra(C1); cout &lt;&lt; cnt[C2] &lt;&lt;" "&lt;&lt; W[C2];&#125;void Dijkstra(int s)&#123; for (int i = 0 ; i &lt; 510; ++i) &#123; if(i==s)&#123; cnt[i] = 1; W[i] = dot_weight[s]; &#125; &#125; d[s] = 0; for(int i=0;i &lt; N;i++)&#123; int u = -1; int MIN = INF; for(int j=0; j &lt; N; j++)&#123; if(isVisit[j]==false &amp;&amp; d[j] &lt; MIN)&#123; u = j; MIN = d[j]; &#125; &#125; isVisit[u] = true; for(int j = 0; j &lt; Adj[u].size(); j++)&#123; int v = Adj[u][j].v; if(isVisit[v]==false &amp;&amp; d[u]+ Adj[u][j].dist &lt; d[v])&#123; d[v] = d[u]+ Adj[u][j].dist; cnt[v] = cnt[u]; W[v] = W[u] + dot_weight[v]; &#125;else if(isVisit[v]==false &amp;&amp; d[u]+ Adj[u][j].dist == d[v])&#123; cnt[v] = cnt[u] + cnt[v]; if(W[v] &lt; W[u] + dot_weight[v])&#123; W[v] = W[u] + dot_weight[v]; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1002]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1002%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef struct Poly&#123; int K; int exp[1005]; double coef[1005];&#125;Poly;int main()&#123; Poly p1,p2; for(int i = 0;i &lt; 1005;i++)&#123; p1.exp[i] = 0; p2.exp[i] = 0; p1.coef[i] = 0; p1.coef[i] = 0; &#125; cin &gt;&gt; p1.K; for(int i = 0;i &lt; p1.K;i++)&#123; int temp; cin &gt;&gt; temp; p1.exp[temp] = 1; cin &gt;&gt; p1.coef[temp]; &#125; cin &gt;&gt; p2.K; for(int i = 0;i &lt; p2.K;i++)&#123; int temp; cin &gt;&gt; temp; p2.exp[temp] = 1; cin &gt;&gt; p2.coef[temp]; &#125; Poly p3; int num = 0; for(int i = 0;i &lt; 1005;i++)&#123; if(p1.exp[i]==1||p2.exp[i]==1)&#123; num++; p3.exp[i] = 1; p3.coef[i] = p1.coef[i] + p2.coef[i]; if(p3.coef[i]==0)&#123;//多项式相加系数为0的情况 p3.exp[i] = 0; num--; &#125; &#125; &#125; if(num==0) cout &lt;&lt;"0";//如果输出一项没有 注意0后面不要有空格 else cout &lt;&lt; num &lt;&lt; " "; int cnt = 0; for(int i = 1004;i &gt;= 0;i--)&#123; if(p3.exp[i] == 1)&#123; cnt++; cout &lt;&lt; i &lt;&lt; " "; printf("%.1lf",p3.coef[i]); if(cnt &lt; num) cout &lt;&lt; " ";//去尾空格 &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1001]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1001%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int a; int b; cin &gt;&gt; a &gt;&gt; b; int c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; "-"; c = -c; &#125; vector&lt;int&gt; vec; int digit = 0; int temp = c; while(temp&gt;=1000)&#123;//计算能除多少个1000 temp = temp/1000; digit += 1; &#125; while(digit &gt;= 0)&#123; int t = c/pow(1000,digit); vec.push_back(t);//商入数组 c = c - t * pow(1000,digit);//余数代替 digit--; &#125; for(int i = 0;i &lt; vec.size();i++)&#123; if(i !=0) printf("%03d",vec[i]); else cout &lt;&lt; vec[i]; if(i != vec.size()-1) cout&lt;&lt;","; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shockhosting——一个小众的VPS运营商]]></title>
    <url>%2F2019%2F09%2F22%2FShockhosting%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BC%97%E7%9A%84VPS%E8%BF%90%E8%90%A5%E5%95%86%2F</url>
    <content type="text"><![CDATA[网址Shockhosting官网不用挂梯子就可以进，但注册的时候如果不挂似乎刷不出验证码，临时有需要可以联系我啦（：购买后页面 优惠码更新时间：2019.9.22 LET30 七折优惠码 下载ssr服务器端时报错wget下载ssr安装时，报根目录容量不够，检查了一下硬盘容量，发现文件系统中 /下只有2个g，可我购买的服务器硬盘有50个g呀。检查了一下磁盘空间确实是20个g，只不过文件系统只占用了22g，剩余的磁盘都空闲。使用以下命令扩大文件系统空间。1resize2fs [空闲磁盘名称]]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>Linux Shell</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下书写JavaWeb最正确的方式——IDEA+Maven+SSM框架]]></title>
    <url>%2F2019%2F09%2F20%2Fmac%E4%B8%8B%E4%B9%A6%E5%86%99JavaWeb%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94IDEA-Maven-SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[GPU版tensorflow环境配置]]></title>
    <url>%2F2019%2F09%2F17%2FGPU%E7%89%88tensorflow%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[版本匹配问题 软件 版本 tensorflow-gpu 1.14.0 cuda 10.0 cuDNN 7.4 显卡驱动 418.74 OS Ubuntu 18.04 Python python 3.6 亲测，按照这版本，显卡风扇已经呼啦啦的转起来了。 一些可能遇到的问题写在最前面: 碰到报错首先读log，根据原因找解决方案 多利用搜索引擎 安装顺序：操作系统-python-显卡驱动-cuda-cuDNN-tensorflow GCC编译器版本可能引起的问题这里要注意的是，使用tensorflow进行training的时候GCC版本要为4.8，而在安装显卡驱动的时候，GCC版本要7.0以上，所以要注意GCC降级的时间。 cuda、cuDNN下载速度个人感觉Ubuntu网卡驱动没有自己的笔记本上的好，导致速度很慢，所以我选择在macOS里下载好安装包再通过u盘或者内网ftp协议传输过去；另外浏览器下载慢可以尝试复制链接迅雷下载。 cuda安装过程建议不勾选安装显卡驱动，而是自己手动安装。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续整数的最小交换排序问题]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[NJU的CS上机指定使用C++，最近抱起《C++Primer》开始肯，同时找到了一个不错的OJ平台——hackerrank，这题是里面碰到的第一个有点困难的题。 原题链接对于输入的一个数组，这个数组纬度为n，且仅含整数 1～$n$ 各一次,例如$$arr = [5,4,3,2,1]$$要求仅使用多次swap方法调换位置，使得该数组递增，即$$arr = [1,2,3,4,5]$$最终要求输出最小的swap次数。 最开始的想法是这样的： $[5,4,3,2,1]$1st: swap(0,4) –&gt; $[1,4,3,2,5]$2nd: swap(1,3) –&gt; $[1,2,3,4,5]$ 即每次从索引为0的地方查起，若发现索引$i$对应的值不是$i+1$，就将该数字与它应在的正确位置想交换；然后开始新一轮的从搜索(从索引0开始)，直到整个数组递增。用c++写出来：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int isCorrect(vector&lt;int&gt; arr);int minimumSwaps(vector&lt;int&gt; arr);int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a; int temp; int i = 0; while (i &lt; n) &#123; cin &gt;&gt; temp; a.push_back(temp); i++; &#125; cout &lt;&lt; minimumSwaps(a);&#125;int minimumSwaps(vector&lt;int&gt; arr)&#123; int count = 0; while (isCorrect(arr) != 1) &#123; int pos; int val; for (int i = 0; i &lt; arr.size(); i++) &#123; if (arr[i] != i + 1) &#123; pos = i; val = arr[i]; break; &#125; &#125; int temp; temp = val; arr[pos] = arr[val - 1]; arr[val - 1] = temp; count++; &#125; return count;&#125;int isCorrect(vector&lt;int&gt; arr)&#123; int flg = 1; for (int i = 0; i &lt; arr.size(); i++) &#123; if (arr[i] != i + 1) &#123; flg = 0; &#125; &#125; return flg;&#125; 信心慢慢提交，发现超时，检查了一下oj的输入数据，超时错误从数据量达到50000开始出现，然后想到是时间复杂度太高的问题，优化过后的代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int num = 0;vector&lt;int&gt; solve(vector&lt;int&gt; arr, int i);int minimumSwaps(vector&lt;int&gt; arr);int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a; int temp; int i = 0; while (i &lt; n) &#123; cin &gt;&gt; temp; a.push_back(temp); i++; &#125; cout &lt;&lt; minimumSwaps(a);&#125;int minimumSwaps(vector&lt;int&gt; arr)&#123; int i = 0; while (i &lt; arr.size()) &#123; if (arr[i] != i + 1) &#123; arr = solve(arr, i); &#125; else &#123; int j = 0; for (j = i + 1; j &lt; arr.size(); j++) &#123; if (arr[j] != j + 1) break; &#125; i = j; if(i != arr.size()) arr = solve(arr, i); &#125; &#125; return num;&#125;vector&lt;int&gt; solve(vector&lt;int&gt; arr, int i)&#123; int pos = i; int val = arr[i]; int temp; temp = val; arr[pos] = arr[val - 1]; arr[val - 1] = temp; num++; return arr;&#125; Submit Accepted呼～嘿嘿]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
