<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2021%2F06%2F10%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义和性质红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质： 性质1：每个节点要么是黑色，要么是红色。 性质2：根节点是黑色。 性质3：每个叶子节点（NIL）是黑色。 性质4：每个红色结点的两个子结点一定都是黑色。 性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点（黑色完美平衡）。定义为黑高black-height 记作bh(x)为便于边界处理，我们采用一个和普通节点拥有相同数据结构的哨兵对象来代表叶节点NIL，叶节点不存储信息，只用来指示边界。 优秀的性质：一棵有n个内部节点的红黑树高度至多为2lg(n+1).因此增删查改操作复杂度都是O（lg n） 红黑树自平衡通过三种操作实现： 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。 变色：结点的颜色由红变黑或由黑变红。上述旋转操作同AVL。 查找因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：（1）从根结点开始查找，把根结点设置为当前结点；（2）若当前结点为空，返回null；（3）若当前结点不为空，用当前结点的key跟查找key作比较；（4）若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；（5）若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；（6）若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2； 插入插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大，需要注意的是插入的节点应该设置成红色，这是因为增加黑色节点必然会引起不平衡（性质5） 需要注意的是，下面所有示意图，圆圈+编号表示的节点（除了明确标出孩子节点的）表示以该编号为根节点的子树。 不会引起自平衡的情况 红黑树为空插入节点作为根节点，设置成黑色； 插入节点key已存在这里按照java hashmap的写法，默认key不重复，因此insert退化为update 插入节点的父节点为黑节点插入节点是红色，直接插入，无需自平衡 需要自平衡的情况插入节点的父节点为红节点可能引起自平衡。首先，因为根节点一定是黑节点，所以插入节点的父节点一定不是跟节点，所以插入节点一定有祖父节点。 叔叔节点存在并且为红节点插入节点是红色，因为红节点的两个子节点必须是黑色，所以首先将插入节点的祖父和父辈的黑红红变为红黑黑，由于祖父节点变为红，对于上层可能会不满足性质4，因此将祖父节点作为新的插入节点（研究对象）。考虑自下而上的变动到达边界条件，即如果祖父节点A是根节点了，必须重新将根节点刷为黑色，这样会使整体黑高增加1，这也是唯一一种会增加黑色节点层数的情景。 叔叔节点不存在或为黑节点以下类似于AVL分左左、左右、右左、右右四种情况 1. 左左 2. 左右 3. 右左 4. 右右 代码]]></content>
  </entry>
  <entry>
    <title><![CDATA[PAT1015-1021]]></title>
    <url>%2F2021%2F03%2F13%2FPAT1015-1021%2F</url>
    <content type="text"><![CDATA[1015 进制转换、素数判断12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int vec2int(vector&lt;int&gt; v, int radix) &#123; int a = 0; for (int i = 0; i &lt; v.size(); i++) &#123; a = a * radix + v[i]; &#125; return a;&#125;vector&lt;int&gt; int2vec(int num, int radix) &#123; vector&lt;int&gt; vec; while (num != 0) &#123; vec.push_back(num % radix); num /= radix; &#125; return vec;//这里是逆向排列的&#125;bool isPrime(int num) &#123; if (num &lt;= 1) return false; for (int i = 2; i &lt; (int) sqrt(1.0 * num) + 1; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125;int main() &#123; int num, radix; while (cin &gt;&gt; num) &#123; if (num &lt; 0) break; else &#123; cin &gt;&gt; radix; if (isPrime(num) &amp;&amp; isPrime(vec2int(int2vec(num, radix), radix))) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125;&#125; 1016 排序、栈、时间处理（未全对）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;map&lt;int, int&gt; hour_price;typedef struct Node &#123; string name; int dd, HH, mm; string state;&#125; record;vector&lt;record&gt; records;string month;int str2int(string a) &#123; int num = 0; for (int i = 0; i &lt; a.size(); i++) &#123; num = num * 10 + a[i] - '0'; &#125; return num;&#125;bool cmp(record a, record b) &#123; if (a.name != b.name) return a.name &lt; b.name; else if (a.dd != b.dd) return a.dd &lt; b.dd; else if (a.HH != b.HH) return a.HH &lt; b.HH; else return a.mm &lt; b.mm;&#125;int count_time(record a, record b) &#123; int time = 0; if (b.mm &lt; a.mm) &#123; time += b.mm + 60 - a.mm; b.HH--; &#125; else &#123; time += b.mm - a.mm; &#125; if (b.HH &lt; a.HH) &#123; time += (b.HH + 12 - a.HH) * 60; b.dd--; &#125; else &#123; time += (b.HH - a.HH) * 60; &#125; time += (b.dd - a.dd) * 24 * 60; return time;&#125;float count_bills(record a, record b) &#123; int head, tail; float bills = 0; bills += (60 - a.mm) * hour_price[a.HH]; bills += (b.mm) * hour_price[b.HH]; a.HH++; float one_day_bills = 0; for (int i = 0; i &lt; 24; i++) &#123; one_day_bills += 60 * hour_price[i]; &#125; if (b.HH &gt; a.HH) &#123; for (int i = a.HH; i &lt; b.HH; i++) &#123; bills += 60 * hour_price[i]; &#125; bills += (b.dd - a.dd) * one_day_bills; &#125; else &#123; for (int i = a.HH; i &lt; 24; i++) &#123; bills += 60 * hour_price[i]; &#125; for (int i = 0; i &lt; b.HH; i++) &#123; bills += 60 * hour_price[i]; &#125; bills += (b.dd - a.dd - 1) * one_day_bills; &#125; return bills / 100;&#125;set&lt;string&gt; st;stack&lt;record&gt; stk;stack&lt;int&gt; temp;bool hasMore(int x) &#123; while(!temp.empty()) temp.pop(); for (int i = x + 1; i &lt; records.size(); i++) &#123; if(records[i].name != records[x].name) break; if(temp.empty()) temp.push(i); else if (records[i].state == "off-line" &amp;&amp; records[i-1].state == "on-line")&#123; return true; &#125;else temp.push(i); &#125; return false;&#125;int main() &#123; for (int i = 0; i &lt; 24; i++) cin &gt;&gt; hour_price[i]; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) &#123; record temp; string str; cin &gt;&gt; temp.name &gt;&gt; str &gt;&gt; temp.state; month = str.substr(0, 2); temp.dd = str2int(str.substr(3, 2)); temp.HH = str2int(str.substr(6, 2)); temp.mm = str2int(str.substr(9, 2)); records.push_back(temp); &#125; sort(records.begin(), records.end(), cmp); float sum = 0; for (int i = 0; i &lt; records.size(); i++) &#123; if (st.find(records[i].name) == st.end()) &#123; cout &lt;&lt; records[i].name &lt;&lt; " " &lt;&lt; month &lt;&lt; endl; st.insert(records[i].name); &#125; record r1, r2; if (records[i].state == "on-line") stk.push(records[i]); else &#123; r1 = stk.top(); stk.pop(); r2 = records[i]; printf("%02d:%02d:%02d ", r1.dd, r1.HH, r1.mm); printf("%02d:%02d:%02d ", r2.dd, r2.HH, r2.mm); cout &lt;&lt; count_time(r1, r2) &lt;&lt; " "; printf("$%.2f\n", count_bills(r1, r2)); sum += count_bills(r1, r2); printf("Total amount: $%.2f\n", sum); sum = 0; &#125; &#125;&#125; 1017 时间处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef struct node &#123; int hh, mm, ss; int P; int wait;&#125; customer;vector&lt;customer&gt; window;vector&lt;customer&gt; customers;int str2int(string s) &#123; int num = 0; for (int i = 0; i &lt; s.size(); i++) &#123; num = num * 10 + s[i] - '0'; &#125; return num;&#125;bool cmp(customer a, customer b) &#123; if (a.hh != b.hh) return a.hh &lt; b.hh; else if (a.mm != b.mm) return a.mm &lt; b.mm; else return a.ss &lt; b.ss;&#125;int delta_time(customer a, customer b) &#123; int sum = 0; if (a.ss &lt; b.ss) &#123; sum += a.ss + 60 - b.ss; a.mm--; &#125; else sum += a.ss - b.ss; if (a.mm &lt; b.mm) &#123; sum += (a.mm + 60 - b.mm) * 60; a.hh--; &#125; else sum += (a.mm - b.mm) * 60; sum += (a.hh - b.hh) * 60 * 60; return sum;&#125;customer add_time(customer a, int P) &#123; a.mm += P; a.hh += a.mm / 60; a.mm = a.mm % 60; return a;&#125;int main() &#123; int N, K; cin &gt;&gt; N &gt;&gt; K; for (int i = 0; i &lt; N; i++) &#123; string str; int time; cin &gt;&gt; str &gt;&gt; time; customer temp; temp.hh = str2int(str.substr(0, 2)); temp.mm = str2int(str.substr(3, 2)); temp.ss = str2int(str.substr(6, 2)); temp.P = time; customers.push_back(temp); &#125; customer initial, final; initial.hh = 8; initial.mm = 0; initial.ss = 0; final.hh = 17; final.mm = 0; final.ss = 0; for (int i = 0; i &lt; K; i++) window.push_back(initial); sort(customers.begin(), customers.end(), cmp); for (auto it = customers.begin(); it != customers.end(); it++) &#123; if (cmp(final, *it)) &#123; customers.erase(it,customers.end()); break; &#125; sort(window.begin(), window.end(), cmp); if (cmp(*it, window[0])) &#123; it-&gt;wait = delta_time(window[0], *it); window[0] = add_time(window[0], it-&gt;P); &#125; else &#123; it-&gt;wait = 0; window[0] = add_time(*it, it-&gt;P); &#125; &#125; double sum = 0; for (int i = 0; i &lt; customers.size(); i++) &#123; sum += customers[i].wait; &#125; printf("%.1f", sum / 60 / customers.size());&#125; 1018 Dijkstra、DFS(未全对)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int C, N, S, M;int INF = 100000000;int dist[510][510];int weight[510];vector&lt;int&gt; Adj[510];bool isVisit[510];int d[510];int w[510];int balance_coef[510];int pre[510];void DFS(int i) &#123; if (isVisit[i]) return; balance_coef[i] = C / 2 - weight[i]; isVisit[i] = true; for (int j = 0; j &lt; Adj[i].size(); j++) &#123; DFS(Adj[i][j]); &#125;&#125;void dijkstra() &#123; fill(isVisit, isVisit + 510, false); d[0] = 0; w[0] = 0; int u = -1; for (int i = 0; i &lt; N; i++) &#123; int min = INF; for (int j = 0; j &lt; N; j++) &#123; if (!isVisit[j] &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = i; &#125; &#125; isVisit[u] = true; for (int j = 0; j &lt; Adj[u].size(); j++) &#123; int v = Adj[u][j]; if (dist[u][v] + d[u] &lt; d[v] &amp;&amp; !isVisit[v]) &#123; d[v] = dist[u][v] + d[u]; w[v] = balance_coef[v] + w[u]; pre[v] = u; &#125; else if (dist[u][v] + d[u] == d[v] &amp;&amp; !isVisit[v]) &#123; if (w[v] &gt; 0 &amp;&amp; w[u] + balance_coef[v] &lt; 0) &#123; w[v] = balance_coef[v] + w[u]; pre[v] = u; &#125; else if (abs(w[v]) &gt; abs(balance_coef[v] + w[u])) &#123; w[v] = balance_coef[v] + w[u]; pre[v] = u; &#125; &#125; &#125; &#125;&#125;void print_route(int i) &#123; if (i == 0) &#123; cout &lt;&lt; 0; return; &#125; print_route(pre[i]); cout &lt;&lt; "-&gt;" &lt;&lt; i;&#125;int main() &#123; fill(d, d + 510, INF); fill(w, w + 510, 0); fill(isVisit, isVisit + 510, false); fill(balance_coef, balance_coef + 510, 0); cin &gt;&gt; C &gt;&gt; N &gt;&gt; S &gt;&gt; M; for (int i = 1; i &lt;= N; i++) &#123; cin &gt;&gt; weight[i]; &#125; for (int i = 0; i &lt; M; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Adj[a].push_back(b); Adj[b].push_back(a); dist[a][b] = c; dist[b][a] = c; &#125; isVisit[0] = true; for (int i = 1; i &lt; N; i++) DFS(i); dijkstra(); if (w[S] &gt; 0) &#123; cout &lt;&lt; w[S] &lt;&lt;" "; print_route(S); cout &lt;&lt; " 0"; &#125;else&#123; cout &lt;&lt; "0 "; print_route(S); cout &lt;&lt; " "&lt;&lt; w[S]; &#125;&#125; 1019 进制转换1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; int2vec(int x,int radix)&#123; int num = x; vector&lt;int&gt; r_vec; vector&lt;int&gt; vec; while(num != 0)&#123; r_vec.push_back(num%radix); num /= radix; &#125; for(int i =r_vec.size()-1;i &gt;= 0;i--)&#123; vec.push_back(r_vec[i]); &#125; return vec;&#125;int main()&#123; int num,radix; cin &gt;&gt; num &gt;&gt; radix; vector&lt;int&gt; vec = int2vec(num,radix); int flag = 0; for(int i = 0;i &lt; vec.size();i++)&#123; if(vec[i]!=vec[vec.size()-i-1]) flag = 1; &#125; if(flag==0) cout &lt;&lt; "Yes"&lt;&lt;endl; else cout &lt;&lt; "No" &lt;&lt; endl; if(num == 0) cout &lt;&lt; 0; else&#123; for(int i = 0;i &lt; vec.size()-1;i++)&#123; cout&lt;&lt;vec[i]&lt;&lt;" "; &#125; cout &lt;&lt;vec[vec.size()-1]; &#125;&#125; 1020 已知树的后序、中序求层次遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int post[30];int in[30];int N;struct Node &#123; int data; Node *l; Node *r;&#125;;Node *Create(int postL, int postR, int inL, int inR) &#123; if (inL &gt; inR) &#123; return NULL; &#125; Node *root = new Node; root-&gt;data = post[postR]; int index; for (int i = inL; i &lt;= inR; ++i) &#123; if (in[i] == post[postR]) &#123; index = i; break; &#125; &#125; int numLeft = index - inL; root-&gt;l = Create(postL, postL + numLeft - 1, inL, inL + numLeft - 1); root-&gt;r = Create(postL + numLeft, postR - 1, inL + numLeft + 1, inR); return root;&#125;void BFS(Node *root) &#123; queue&lt;Node *&gt; q; q.push(root); int i = 0; while (!q.empty()) &#123; Node *front = q.front(); q.pop(); cout &lt;&lt; front-&gt;data; if (i &lt; N - 1) cout &lt;&lt; " "; i++; if (front-&gt;l != NULL) q.push(front-&gt;l); if (front-&gt;r != NULL) q.push(front-&gt;r); &#125;&#125;int main() &#123; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; post[i]; &#125; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; in[i]; &#125; Node *root = Create(0, N - 1, 0, N - 1); BFS(root);&#125; 1021 并查集测连通分量、DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;//并查集+DFSusing namespace std;vector&lt;int&gt; Adj[10005];int isVisit[10005];int level;int depth[10005];int father[10005];void DFS(int s, int &amp;max) &#123; if (isVisit[s]) return; level++; isVisit[s] = true; for (int i = 0; i &lt; Adj[s].size(); i++) &#123; DFS(Adj[s][i], max); &#125; max = max &lt; level ? level : max; level--;&#125;int findFather(int x) &#123; while (x != father[x]) &#123; x = father[x]; &#125; return x;&#125;int main() &#123; int N; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) father[i] = i; for (int i = 0; i &lt; N - 1; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Adj[a].push_back(b); Adj[b].push_back(a); int x = findFather(a); int y = findFather(b); if(x!=y) father[y]=x; &#125; for (int i = 1; i &lt; N + 1; i++) &#123; fill(isVisit, isVisit + 10005, false); level = 0; int m = 0; DFS(i, m); depth[i] = m; &#125; int components_num = 0; for (int i = 1; i &lt;= N; i++) &#123; if (father[i] == i) components_num++; &#125; if (components_num &gt;= 2) &#123; cout &lt;&lt; "Error: " &lt;&lt; components_num &lt;&lt; " components"; return 0; &#125; vector&lt;int&gt; ans; int max = 0; for (int i = 1; i &lt; N + 1; i++) &#123; if (max &lt; depth[i]) max = depth[i]; &#125; for (int i = 1; i &lt; N + 1; i++) &#123; if (max == depth[i]) ans.push_back(i); &#125; for (int i = 0; i &lt; ans.size(); i++) cout &lt;&lt; ans[i] &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2020%2F06%2F22%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[PAT中常用的进制转化，包括string、vector和int间的按进制转换。string类型可以直接使用iostream读入:cin &gt;&gt; str具体写法如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;int toNumber_str(string x, int radix) &#123; int a = 0; for (int i = 0; i &lt; x.size(); i++) &#123; a = a * radix + (x[i] - '0'); &#125; return a;&#125;int toNumber_vec(vector&lt;int&gt; x, int radix) &#123; int a = 0; for (int i = 0; i &lt; x.size(); i++) &#123; a = a * radix + x[i]; &#125; return a;&#125;string toString(int num,int radix)&#123; string s = ""; while(num!=0)&#123; char a[10]; sprintf(a,"%d",num % radix); string str = a; s += a; num /= radix; &#125; return s;&#125;vector&lt;int&gt; toVector(int num,int radix)&#123; vector&lt;int&gt; vec; while(num!=0)&#123; vec.push_back(num % radix); num /= radix; &#125; return vec;&#125;int main() &#123; /* * 字符串,int数组按进制转int */ string s = "12345"; vector&lt;int&gt; vec; for(int i = 1;i &lt;= 5;i++)&#123; vec.push_back(i); &#125; cout &lt;&lt; toNumber_str(s,10)&lt;&lt;endl;//12345 cout &lt;&lt; toNumber_vec(vec,10)&lt;&lt;endl;//12345 /* * int按进制转字符串,int数组（逆向） */ int a = 12345; vector&lt;int&gt; v = toVector(a,10);//"54321" string str = toString(a,10);//"54321" /* * int转字符串（正向，仅支持10进制） */ char b[10]; int size = sprintf(b,"%d",a); for(int i = 0;i &lt; size;i++) cout &lt;&lt; b[i];//"12345"&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1006-1014]]></title>
    <url>%2F2020%2F06%2F21%2FPAT1006-1014%2F</url>
    <content type="text"><![CDATA[1006123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; string id; string in; string out;&#125; Node;bool cmp1(Node a, Node b) &#123; string str1 = a.in; string str2 = b.in; string HH1 = str1.substr(0, 2); string MM1 = str1.substr(3, 2); string SS1 = str1.substr(6, 2); string HH2 = str2.substr(0, 2); string MM2 = str2.substr(3, 2); string SS2 = str2.substr(6, 2); if (HH1 == HH2) &#123; if (MM1 == MM2) &#123; return SS1 &lt; SS2; &#125; else return MM1 &lt; MM2; &#125; else return HH1 &lt; HH2;&#125;bool cmp2(Node a, Node b) &#123; string str1 = a.out; string str2 = b.out; string HH1 = str1.substr(0, 2); string MM1 = str1.substr(3, 2); string SS1 = str1.substr(6, 2); string HH2 = str2.substr(0, 2); string MM2 = str2.substr(3, 2); string SS2 = str2.substr(6, 2); if (HH1 == HH2) &#123; if (MM1 == MM2) &#123; return SS1 &gt; SS2; &#125; else return MM1 &gt; MM2; &#125; else return HH1 &gt; HH2;&#125;int main() &#123; int n; cin &gt;&gt; n; Node node[n]; for (int i = 0; i &lt; n; i++) &#123; string a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; node[i].id = a; node[i].in = b; node[i].out = c; &#125; sort(node, node + n, cmp1); cout &lt;&lt; node[0].id &lt;&lt; " "; sort(node, node + n, cmp2); cout &lt;&lt; node[0].id ;&#125; 100712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; /* * 活用递推，先求S[i] = S[i-1] + a[i] * 从左至右找到最大的一个S，下标为index2 * 从0至index2找到最小的一个S，下标为index1 * 答案为a[index1+1]~a[index2] */ int K; vector&lt;int&gt; a; vector&lt;int&gt; s; cin &gt;&gt; K; for (int i = 0; i &lt; K; i++) &#123; int temp; cin &gt;&gt; temp; a.push_back(temp); &#125; int MIN = 100000000; int MAX = -100000000; int index1 = -1, index2 = -1; s.push_back(a[0]); for (int i = 1; i &lt; K; i++) &#123; s.push_back(s[i - 1] + a[i]); &#125; for (int i = 0; i &lt; K; i++) &#123; if (s[i] &gt; MAX) &#123; MAX = s[i]; index2 = i; &#125; &#125; if(MAX &lt; 0)&#123;//如果最大的s还是负的或0，此时可能出现尽管S都负但a[n]中存在正数的情况，因此需要找到第二大的S 例如&#123;-1 -1 1 -3&#125; MAX = -100000000; for (int i = index2 + 1; i &lt; K; i++) &#123; if (s[i] &gt; MAX) &#123; MAX = s[i]; index2 = i; &#125; &#125; &#125; for (int i = 0; i &lt; index2; i++) &#123; if (s[i] &lt; MIN) &#123; MIN = s[i]; index1 = i; &#125; &#125; index1 += 1; bool isAllNeg = true; for(int i =0;i &lt; K;i++)&#123; if(a[i]&gt;=0)&#123; isAllNeg = false; break; &#125; &#125; if (isAllNeg) &#123; cout &lt;&lt; 0 &lt;&lt; " " &lt;&lt; a[0] &lt;&lt; " " &lt;&lt; a[K-1]; &#125; else &#123; int sum = 0; for (int i = index1; i &lt;= index2; i++) &#123; sum = sum + a[i]; &#125; cout &lt;&lt; sum &lt;&lt; " " &lt;&lt; a[index1] &lt;&lt; " " &lt;&lt; a[index2]; &#125;&#125; 1008123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; int n, total = 0, now = 0, to; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;to; if (to &gt; now)total += ((to - now) * 6); else total += ((now - to) * 4); total += 5; now = to; &#125; cout &lt;&lt; total; return 0;&#125; 1009123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct Poly&#123; vector&lt;int&gt; exp; double coef[2005]; Poly()&#123; fill(coef,coef+2005,0.0); &#125;&#125;Poly;int main()&#123; int k; Poly poly1,poly2; cin &gt;&gt; k; for(int i = 0;i &lt; k;i++)&#123; int p1; double p2; cin &gt;&gt; p1 &gt;&gt; p2; poly1.exp.push_back(p1); poly1.coef[p1] = p2; &#125; cin &gt;&gt; k; for(int i = 0;i &lt; k;i++)&#123; int p1; double p2; cin &gt;&gt; p1 &gt;&gt; p2; poly2.exp.push_back(p1); poly2.coef[p1] = p2; &#125; Poly poly3; int hasExp[2005]; fill(hasExp,hasExp+2005,0); for(int i = 0;i &lt; poly1.exp.size();i++)&#123; for(int j = 0;j &lt; poly2.exp.size();j++)&#123; int exp = poly1.exp[i]+poly2.exp[j]; double coef = poly1.coef[poly1.exp[i]]*poly2.coef[poly2.exp[j]]; if(hasExp[exp]==0)&#123; poly3.exp.push_back(exp); hasExp[exp] = 1; &#125; poly3.coef[exp]+=coef; &#125; &#125; int cnt = 0; for(int i = 2004;i &gt;= 0;i--)&#123; if(hasExp[i] == 1 &amp;&amp; poly3.coef[i]!=0)&#123; cnt++; &#125; &#125; if(cnt==0) cout &lt;&lt;"0";//如果输出一项没有 注意0后面不要有空格 else cout &lt;&lt; cnt &lt;&lt; " "; int num = 0; for(int i = 2004;i &gt;= 0;i--)&#123; if(hasExp[i] == 1 &amp;&amp; poly3.coef[i]!=0)&#123; num++; cout &lt;&lt; i &lt;&lt; " "; printf("%.1lf",poly3.coef[i]); if(num &lt; cnt) cout &lt;&lt; " ";//去尾空格 &#125; &#125;&#125; 1010123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;char tmp1[15],str1[15];char tmp2[15],str2[15];long long num1=0,num2=0; int flag;typedef long long LL;LL radix;LL inf=(1LL&lt;&lt;63)-1; long long convert(char str[],LL radix,LL t)&#123; long long num=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')&#123; num=num*radix+str[i]-'0'; &#125; else if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z')&#123; num=num*radix+(str[i]-'a'+10); &#125; &#125; if(num&lt;0) return -1; return num;&#125; int findLargest(char str[])&#123; int MAX=0; for(int i=0;i&lt;strlen(str);i++)&#123; if(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9') MAX=max(MAX,str[i]-'0'); else if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') MAX=max(MAX,str[i]-'a'+10); &#125; return MAX+1;&#125; int main()&#123; scanf("%s %s %d %d",tmp1,tmp2,&amp;flag,&amp;radix); if(flag==1)&#123; strcpy(str1,tmp1); strcpy(str2,tmp2); &#125; else if(flag==2)&#123; strcpy(str1,tmp2); strcpy(str2,tmp1); &#125; num1=convert(str1,radix,inf); long long l=0,r=400,mid; l=findLargest(str2); r=max(l,num1)+1; bool f=false; while(l&lt;r)&#123; mid=(l+r)/2; long long tmp=convert(str2,mid,inf); if(tmp==-1) r=mid; else if(tmp==num1)&#123; printf("%lld\n",mid); f=true; break; &#125; else if(tmp&lt;num1) l=mid+1; else r=mid; &#125; if(f==false) printf("Impossible\n"); return 0;&#125; 1011123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;double a[3],b[3],c[3];typedef struct Node&#123; int index; double max;&#125;Node;Node findMax(double x[])&#123; Node node; double max = -1.0; int index = -1; for(int i =0;i &lt; 3;i++)&#123; if(x[i]&gt;max)&#123; max = x[i]; index = i; &#125; &#125; node.index = index; node.max = max; return node;&#125;int main()&#123; cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2]; cin &gt;&gt; b[0] &gt;&gt; b[1] &gt;&gt; b[2]; cin &gt;&gt; c[0] &gt;&gt; c[1] &gt;&gt; c[2]; Node node1 = findMax(a); Node node2 = findMax(b); Node node3 = findMax(c); char mp[3]=&#123;'W','T','L'&#125;; cout &lt;&lt; mp[node1.index]&lt;&lt;" "&lt;&lt;mp[node2.index]&lt;&lt;" "&lt;&lt; mp[node3.index]&lt;&lt;" "; printf("%.2lf",(0.65*node1.max*node2.max*node3.max-1)*2);&#125; 1012123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;typedef struct Node &#123; int id; int C, M, E, A, rC, rM, rE, rA;&#125; Node;bool cmp1(Node a, Node b) &#123; return a.C &gt; b.C;&#125;bool cmp2(Node a, Node b) &#123; return a.M &gt; b.M;&#125;bool cmp3(Node a, Node b) &#123; return a.E &gt; b.E;&#125;bool cmp4(Node a, Node b) &#123; return a.A &gt; b.A;&#125;int main() &#123; int N, M; cin &gt;&gt; N &gt;&gt; M; Node node[N]; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; node[i].id &gt;&gt; node[i].C &gt;&gt; node[i].M &gt;&gt; node[i].E; node[i].A = (node[i].C + node[i].M + node[i].E) / 3; &#125; sort(node, node + N, cmp1); node[0].rC = 1; int temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].C == node[i-1].C)&#123; node[i].rC = node[i-1].rC; temp++; &#125; else node[i].rC = ++temp; &#125; sort(node, node + N, cmp2); node[0].rM = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].M == node[i-1].M)&#123; node[i].rM = node[i-1].rM; temp++; &#125; else node[i].rM = ++temp; &#125; sort(node, node + N, cmp3); node[0].rE = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].E == node[i-1].E)&#123; node[i].rE = node[i-1].rE; temp++; &#125; else node[i].rE = ++temp; &#125; sort(node, node + N, cmp4); node[0].rA = 1; temp = 1; for (int i = 1; i &lt; N; i++) &#123; if(node[i].A == node[i-1].A)&#123; node[i].rA = node[i-1].rA; temp++; &#125; else node[i].rA = ++temp; &#125; map&lt;int, Node&gt; mp; for (int i = 0; i &lt; N; i++) &#123; mp[node[i].id] = node[i]; &#125; for (int i = 0; i &lt; M; i++) &#123; int input; cin &gt;&gt; input; if (mp.find(input) == mp.end()) cout &lt;&lt; "N/A"&lt;&lt;endl; else &#123; Node t = mp[input]; int rank = 100000; int index = -1; int acme[4]; char hashMap[4]; acme[0] = t.rA; hashMap[0] = 'A'; acme[1] = t.rC; hashMap[1] = 'C'; acme[2] = t.rM; hashMap[2] = 'M'; acme[3] = t.rE; hashMap[3] = 'E'; for (int j = 0; j &lt; 4; j++) &#123; if (acme[j] &lt; rank) &#123; rank = acme[j]; index = j; &#125; &#125; cout &lt;&lt; rank &lt;&lt; " " &lt;&lt; hashMap[index] &lt;&lt; endl; &#125; &#125;&#125; 10131234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; Adj[1010];bool isVisit[1010] = &#123;false&#125;;int num = 0;void DFS(int s,vector&lt;int&gt; a[]) &#123; isVisit[s] = true; for (int i = 0; i &lt; a[s].size(); i++) &#123; if (!isVisit[a[s][i]]) DFS(a[s][i],a); &#125;&#125;int main() &#123; int N, M, K; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 0; i &lt; M; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; Adj[a].push_back(b); Adj[b].push_back(a); &#125; vector&lt;int&gt; Adj_copy[1010]; for (int i = 0; i &lt; K; i++) &#123; for (int m = 0; m &lt; N + 1; m++) &#123; Adj_copy[m] = Adj[m]; &#125; int t; cin &gt;&gt; t; Adj_copy[t].clear(); for (int j = 1; j &lt; N + 1; j++) &#123; for (auto it = Adj_copy[j].begin(); it &lt; Adj_copy[j].end(); it++) &#123; if (*it == t) Adj_copy[j].erase(it); &#125; &#125; num = 0; fill(isVisit, isVisit + 1010, false); for (int k = 1; k &lt; N + 1; k++) &#123; if (!isVisit[k]) &#123; DFS(k,Adj_copy); num++; &#125; &#125; cout &lt;&lt; num - 2 &lt;&lt; endl; &#125;&#125; 1014123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct Node&#123; int time1; int time2;&#125;node[1010];typedef struct Time&#123; int HH; int MM;&#125;Time;vector&lt;queue&lt;int&gt; &gt; queues;vector&lt;vector&lt;int&gt; &gt; vec_queues;int time_consume[1010];Time SS2HHMM(int s)&#123;//秒数转为HH:MM int h = 8 + s / 60; int m = s - (s / 60) * 60; Time time; time.HH = h; time.MM = m; return time;&#125;int main()&#123; int N,M,K,Q; cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; Q; for(int i = 0;i &lt; N;i++)&#123; queue&lt;int&gt; q; vector&lt;int&gt; v; queues.push_back(q); vec_queues.push_back(v); &#125; for(int i = 1;i &lt; K+1;i++)&#123; cin &gt;&gt; time_consume[i]; &#125; int index = 1; for(int s = 0; s &lt; M;s++)&#123; for(int i = 0;i &lt; queues.size();i++)&#123; queues[i].push(index); vec_queues[i].push_back(index); int vec_size = vec_queues[i].size(); node[index].time1 = 0; if(index == queues[i].front())&#123; node[index].time2 = time_consume[index]; &#125;else&#123; node[index].time2 = node[vec_queues[i][vec_size - 2]].time2 + time_consume[index]; &#125; index++; &#125; &#125; bool isFinished = true;// for(int i = 0;i &lt; queues.size();i++)&#123;// if(!queues[i].empty()) isFinished = false;// &#125; while(index &lt;= K)&#123; int min = 100000; int t = -1; for(int i = 0;i &lt; queues.size();i++)&#123; if(node[queues[i].front()].time2 &lt; min)&#123; min = node[queues[i].front()].time2; t = i; &#125; &#125; int front = queues[t].front(); queues[t].pop(); queues[t].push(index); node[index].time1 = node[front].time2; vec_queues[t].push_back(index); int vec_size = vec_queues[t].size(); node[index].time2 = node[vec_queues[t][vec_size - 2]].time2 + time_consume[index]; index++; &#125; for(int i = 0;i &lt; Q;i++)&#123; int q; cin &gt;&gt; q; int start_time = node[q].time1; int finish_time = node[q].time2; if((finish_time - time_consume[q]) &gt;= 540) cout &lt;&lt; "Sorry"&lt;&lt;endl; else &#123; printf("%02d:%02d\n",SS2HHMM(finish_time).HH,SS2HHMM(finish_time).MM); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Djikstra题型总结]]></title>
    <url>%2F2020%2F06%2F14%2FDjikstra%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述使用Dijkstra的最短路的问题通常不仅要求给出最短路径，还附带以下几种题型或其组合： 额外增加一个边权，用于最短路径相同情况下的比较； 额外增加一个点权，用于最短路径相同情况下的比较； 问有多少种最短路； 输出最短路经过节点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXV = 510; //最大顶点数，通常取题目所给条件的上限+（5～10）即可const int INF = 100000000;//定义一个很大的数vector&lt;int&gt; Adj[MAXV];//图的邻接表（可以选择用vector&lt;Node&gt; Adj[] 结构体中放入边权和点权）int d[MAXV];//第一线权（从起点s到顶点u的最短路程为d[u]）int w[MAXV];//点权（从起点s到顶点u能收集到的最多的点权为w[u]）int c[MAXV];//第二线权（从起点s到顶点u花费的最少线权为c[u]）int num[MAXV];//记录相同距离路径个数int pre[MAXV];//从起点到v的最短路径的v的前一个节点为pre[v]int weight[MAXV];//存储输入的点权int dist[MAXV][MAXV];//存储输入的第一线权int cost[MAXV][MAXV];//存储输入的第二线权bool isVisit[MAXV];//用来记录是否访问过int M,N;void Dijkstra(int s);void print_route(int s, int v);int main()&#123; /* * 输入的格式 * N（节点个数） M（边个数） * w1 w2 ... wN （点权） * v1 v2 distance cost (两顶点编号，以及两者间的两种边权) */ cin &gt;&gt; M &gt;&gt; N; for(int i = 0;i &lt; N;i++)&#123; int temp; cin &gt;&gt; temp; weight[i] = temp; &#125; for(int i = 0; i &lt; M;i++)&#123; int v1,v2,distance,cost_; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; distance &gt;&gt; cost_; dist[v1][v2] = distance; cost[v1][v2] = cost_; &#125; /* * 初始化全局变量 */ fill(d,d+MAXV,INF);//初始d都为0 fill(w,w+MAXV,0); fill(c,c+MAXV,0); fill(num,num+MAXV,0); num[0] = 1; Dijkstra(0);&#125;void Dijkstra(int s)&#123;//s为起点 d[s] = 0;//起点到自己距离为0 int u = -1;//用来记录当前的顶点 for(int i = 0; i &lt; N; i++)&#123;//计算到每个点的最短路径 int MIN = INF; for(int j = 0;j &lt; N;j++)&#123; if(isVisit[j]== false &amp;&amp; d[j] &lt; MIN)&#123; u = j; MIN = d[j]; &#125; &#125; isVisit[u] = true; for(int j=0; j &lt; Adj[u].size();j++)&#123; int v = Adj[u][j]; if(isVisit[v] == false &amp;&amp; d[u] + dist[u][v] &lt; d[v])&#123;//优先级：第一线 &gt; 第二线 &gt; 点 d[v] = d[u] + dist[u][v];//第一线权 c[v] = c[u] + cost[u][v];//第二线权 w[v] = w[u] + weight[v];//点权 num[v] = num[u]; pre[v] = u; &#125;else if(isVisit[v] == false &amp;&amp; d[u] + dist[u][v] == d[v])&#123; num[v] = num[v] + num[u];//加法原理 if(c[v] &gt; c[u] + cost[u][v])&#123; c[v] = c[u] + cost[u][v];//选择更小的花费 pre[v] = u; &#125;else if(c[v] == c[u] + cost[u][v])&#123; if(w[v] &lt; w[u] + weight[v])&#123; w[v] = w[u] + weight[v]; pre[v] = u; &#125; &#125; &#125; &#125; print_route(s, i); cout &lt;&lt; "\n"; &#125;&#125;void print_route(int s, int v)&#123;//类似于并查集或DFS if(v==s)&#123; cout &lt;&lt; s; return; &#125; print_route(s,pre[v]); cout &lt;&lt; v;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1005]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1005%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string input; cin &gt;&gt; input;//cin直接传给string类型，注意这是STL里的string，不是cstring int sum = 0; for(int i = 0;i &lt; input.size(); i++)&#123; sum += input[i] - '0'; &#125; string hash[10]; hash[0] = "zero"; hash[1] = "one"; hash[2] = "two"; hash[3] = "three"; hash[4] = "four"; hash[5] = "five"; hash[6] = "six"; hash[7] = "seven"; hash[8] = "eight"; hash[9] = "nine"; char output[1000]; int num = sprintf(output,"%d",sum); /* sprintf函数，可以手写，类似于进制转换，将int型转换为数字字符串，返回值为转换成的字符串的大小（不包括结尾\0） **/ for(int i = 0; i &lt; num; i++)&#123; if(i == 0) cout &lt;&lt; hash[output[i] - '0']; else cout&lt;&lt;" "&lt;&lt; hash[output[i] - '0']; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1004]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1004%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 105;vector&lt;int&gt; Node[N];int level[N] = &#123;0&#125;;int leaf[N] = &#123;0&#125;;int max_level = 0;void BFS()&#123; queue&lt;int&gt; Q; Q.push(1); while(!Q.empty())&#123; int front = Q.front(); Q.pop(); max_level = max(max_level,level[front]); if(Node[front].size() == 0)&#123; leaf[level[front]]++; &#125; for(int i = 0; i &lt; Node[front].size(); i++)&#123; level[Node[front][i]] = level[front] + 1; Q.push(Node[front][i]); &#125; &#125;&#125;int main()&#123; int n,m; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++)&#123; int parent, k, child; cin &gt;&gt; parent &gt;&gt; k; for(int j =0; j &lt; k;j++)&#123; cin &gt;&gt; child; Node[parent].push_back(child); &#125; &#125; BFS(); for(int i = 0; i &lt;= max_level; i++)&#123; if(i == 0) cout &lt;&lt; leaf[i]; else cout &lt;&lt; " " &lt;&lt; leaf[i]; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1003]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1003%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct Node&#123; int v; int dist;&#125;;const int INF = 10000000;int N,M,C1,C2;vector&lt;Node&gt; Adj[510];int dot_weight[510];int d[510];int W[510];int cnt[510];bool isVisit[510] = &#123;false&#125;;void Dijkstra(int s);int main()&#123; fill(d,d+510,INF);//两种不同方法效果一样 //memset(d,INF,sizeof(d)); fill(W,W+510,0); fill(cnt,cnt+510,1); fill(dot_weight,dot_weight+510,0); cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; for(int i =0;i &lt; N ;i++)&#123; cin &gt;&gt; dot_weight[i]; &#125; for(int i = 0;i &lt; M;i++)&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Node node1, node2; node1.v = a; node2.v = b; node1.dist = node2.dist = c; Adj[a].push_back(node2); Adj[b].push_back(node1); &#125; Dijkstra(C1); cout &lt;&lt; cnt[C2] &lt;&lt;" "&lt;&lt; W[C2];&#125;void Dijkstra(int s)&#123; for (int i = 0 ; i &lt; 510; ++i) &#123; if(i==s)&#123; cnt[i] = 1; W[i] = dot_weight[s]; &#125; &#125; d[s] = 0; for(int i=0;i &lt; N;i++)&#123; int u = -1; int MIN = INF; for(int j=0; j &lt; N; j++)&#123; if(isVisit[j]==false &amp;&amp; d[j] &lt; MIN)&#123; u = j; MIN = d[j]; &#125; &#125; isVisit[u] = true; for(int j = 0; j &lt; Adj[u].size(); j++)&#123; int v = Adj[u][j].v; if(isVisit[v]==false &amp;&amp; d[u]+ Adj[u][j].dist &lt; d[v])&#123; d[v] = d[u]+ Adj[u][j].dist; cnt[v] = cnt[u]; W[v] = W[u] + dot_weight[v]; &#125;else if(isVisit[v]==false &amp;&amp; d[u]+ Adj[u][j].dist == d[v])&#123; cnt[v] = cnt[u] + cnt[v]; if(W[v] &lt; W[u] + dot_weight[v])&#123; W[v] = W[u] + dot_weight[v]; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1002]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1002%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;typedef struct Poly&#123; int K; int exp[1005]; double coef[1005];&#125;Poly;int main()&#123; Poly p1,p2; for(int i = 0;i &lt; 1005;i++)&#123; p1.exp[i] = 0; p2.exp[i] = 0; p1.coef[i] = 0; p1.coef[i] = 0; &#125; cin &gt;&gt; p1.K; for(int i = 0;i &lt; p1.K;i++)&#123; int temp; cin &gt;&gt; temp; p1.exp[temp] = 1; cin &gt;&gt; p1.coef[temp]; &#125; cin &gt;&gt; p2.K; for(int i = 0;i &lt; p2.K;i++)&#123; int temp; cin &gt;&gt; temp; p2.exp[temp] = 1; cin &gt;&gt; p2.coef[temp]; &#125; Poly p3; int num = 0; for(int i = 0;i &lt; 1005;i++)&#123; if(p1.exp[i]==1||p2.exp[i]==1)&#123; num++; p3.exp[i] = 1; p3.coef[i] = p1.coef[i] + p2.coef[i]; if(p3.coef[i]==0)&#123;//多项式相加系数为0的情况 p3.exp[i] = 0; num--; &#125; &#125; &#125; if(num==0) cout &lt;&lt;"0";//如果输出一项没有 注意0后面不要有空格 else cout &lt;&lt; num &lt;&lt; " "; int cnt = 0; for(int i = 1004;i &gt;= 0;i--)&#123; if(p3.exp[i] == 1)&#123; cnt++; cout &lt;&lt; i &lt;&lt; " "; printf("%.1lf",p3.coef[i]); if(cnt &lt; num) cout &lt;&lt; " ";//去尾空格 &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT1001]]></title>
    <url>%2F2020%2F06%2F14%2FPAT1001%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int a; int b; cin &gt;&gt; a &gt;&gt; b; int c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; "-"; c = -c; &#125; vector&lt;int&gt; vec; int digit = 0; int temp = c; while(temp&gt;=1000)&#123;//计算能除多少个1000 temp = temp/1000; digit += 1; &#125; while(digit &gt;= 0)&#123; int t = c/pow(1000,digit); vec.push_back(t);//商入数组 c = c - t * pow(1000,digit);//余数代替 digit--; &#125; for(int i = 0;i &lt; vec.size();i++)&#123; if(i !=0) printf("%03d",vec[i]); else cout &lt;&lt; vec[i]; if(i != vec.size()-1) cout&lt;&lt;","; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shockhosting——一个小众的VPS运营商]]></title>
    <url>%2F2019%2F09%2F22%2FShockhosting%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BC%97%E7%9A%84VPS%E8%BF%90%E8%90%A5%E5%95%86%2F</url>
    <content type="text"><![CDATA[网址Shockhosting官网不用挂梯子就可以进，但注册的时候如果不挂似乎刷不出验证码，临时有需要可以联系我啦（：购买后页面 优惠码更新时间：2019.9.22 LET30 七折优惠码 下载ssr服务器端时报错wget下载ssr安装时，报根目录容量不够，检查了一下硬盘容量，发现文件系统中 /下只有2个g，可我购买的服务器硬盘有50个g呀。检查了一下磁盘空间确实是20个g，只不过文件系统只占用了22g，剩余的磁盘都空闲。使用以下命令扩大文件系统空间。1resize2fs [空闲磁盘名称]]]></content>
      <categories>
        <category>VPS</category>
      </categories>
      <tags>
        <tag>Linux Shell</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下书写JavaWeb最正确的方式——IDEA+Maven+SSM框架]]></title>
    <url>%2F2019%2F09%2F20%2Fmac%E4%B8%8B%E4%B9%A6%E5%86%99JavaWeb%E6%9C%80%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94IDEA-Maven-SSM%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[GPU版tensorflow环境配置]]></title>
    <url>%2F2019%2F09%2F17%2FGPU%E7%89%88tensorflow%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[版本匹配问题 软件 版本 tensorflow-gpu 1.14.0 cuda 10.0 cuDNN 7.4 显卡驱动 418.74 OS Ubuntu 18.04 Python python 3.6 亲测，按照这版本，显卡风扇已经呼啦啦的转起来了。 一些可能遇到的问题写在最前面: 碰到报错首先读log，根据原因找解决方案 多利用搜索引擎 安装顺序：操作系统-python-显卡驱动-cuda-cuDNN-tensorflow GCC编译器版本可能引起的问题这里要注意的是，使用tensorflow进行training的时候GCC版本要为4.8，而在安装显卡驱动的时候，GCC版本要7.0以上，所以要注意GCC降级的时间。 cuda、cuDNN下载速度个人感觉Ubuntu网卡驱动没有自己的笔记本上的好，导致速度很慢，所以我选择在macOS里下载好安装包再通过u盘或者内网ftp协议传输过去；另外浏览器下载慢可以尝试复制链接迅雷下载。 cuda安装过程建议不勾选安装显卡驱动，而是自己手动安装。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续整数的最小交换排序问题]]></title>
    <url>%2F2019%2F07%2F15%2F%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[NJU的CS上机指定使用C++，最近抱起《C++Primer》开始肯，同时找到了一个不错的OJ平台——hackerrank，这题是里面碰到的第一个有点困难的题。 原题链接对于输入的一个数组，这个数组纬度为n，且仅含整数 1～$n$ 各一次,例如$$arr = [5,4,3,2,1]$$要求仅使用多次swap方法调换位置，使得该数组递增，即$$arr = [1,2,3,4,5]$$最终要求输出最小的swap次数。 最开始的想法是这样的： $[5,4,3,2,1]$1st: swap(0,4) –&gt; $[1,4,3,2,5]$2nd: swap(1,3) –&gt; $[1,2,3,4,5]$ 即每次从索引为0的地方查起，若发现索引$i$对应的值不是$i+1$，就将该数字与它应在的正确位置想交换；然后开始新一轮的从搜索(从索引0开始)，直到整个数组递增。用c++写出来：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int isCorrect(vector&lt;int&gt; arr);int minimumSwaps(vector&lt;int&gt; arr);int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a; int temp; int i = 0; while (i &lt; n) &#123; cin &gt;&gt; temp; a.push_back(temp); i++; &#125; cout &lt;&lt; minimumSwaps(a);&#125;int minimumSwaps(vector&lt;int&gt; arr)&#123; int count = 0; while (isCorrect(arr) != 1) &#123; int pos; int val; for (int i = 0; i &lt; arr.size(); i++) &#123; if (arr[i] != i + 1) &#123; pos = i; val = arr[i]; break; &#125; &#125; int temp; temp = val; arr[pos] = arr[val - 1]; arr[val - 1] = temp; count++; &#125; return count;&#125;int isCorrect(vector&lt;int&gt; arr)&#123; int flg = 1; for (int i = 0; i &lt; arr.size(); i++) &#123; if (arr[i] != i + 1) &#123; flg = 0; &#125; &#125; return flg;&#125; 信心慢慢提交，发现超时，检查了一下oj的输入数据，超时错误从数据量达到50000开始出现，然后想到是时间复杂度太高的问题，优化过后的代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int num = 0;vector&lt;int&gt; solve(vector&lt;int&gt; arr, int i);int minimumSwaps(vector&lt;int&gt; arr);int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a; int temp; int i = 0; while (i &lt; n) &#123; cin &gt;&gt; temp; a.push_back(temp); i++; &#125; cout &lt;&lt; minimumSwaps(a);&#125;int minimumSwaps(vector&lt;int&gt; arr)&#123; int i = 0; while (i &lt; arr.size()) &#123; if (arr[i] != i + 1) &#123; arr = solve(arr, i); &#125; else &#123; int j = 0; for (j = i + 1; j &lt; arr.size(); j++) &#123; if (arr[j] != j + 1) break; &#125; i = j; if(i != arr.size()) arr = solve(arr, i); &#125; &#125; return num;&#125;vector&lt;int&gt; solve(vector&lt;int&gt; arr, int i)&#123; int pos = i; int val = arr[i]; int temp; temp = val; arr[pos] = arr[val - 1]; arr[val - 1] = temp; num++; return arr;&#125; Submit Accepted呼～嘿嘿]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
